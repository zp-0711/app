### 脚手架文件结构

```
|——mode_modules
|——public
|    |——favicon.ico:页签图标
|     |__index.html :主页面
|
|——src
|   |——assets：存放静态资源
|   |    |__logo.png
|   |——component：存放组件
|   |     |__HelloWorld.vue
|   |——App.vue: 汇总所有组件
|   |——main.js:入口文件
|———.gitignore ：get版本管理忽略的配置
|—— babel.config.js ：babel的配置文件
|-- package.json ：应用包配置文件
|--README.MD：应用描述文件
|——package-lock.json ：包版本控制文件
```

### 关于不同版本的Vue：

- 1.vue.js与vue.runtime.xxx.js的区别：

​    （1）vue.js是完整版的Vue，包含：核心功能+模板解析器

​    （2）vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器

- 2.因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用

  reder函数接收到的createElement函数去指定具体的内容 。

vue.config.js配置文件

使用vue.inspect>output,js 可以查看Vue脚手架的默认设置

使用vue.config.js可以对脚手架进行个性化定制，详情见：http://cli.vuejs.org/zh

### ref 属性
1.被同来给元素或子组件注册引用信息（id的代替者）
2.应用在html标签上获取的是真实DOM元素，应用在组件标签上时组件实例对象（vc)
3.使用方式：
   打标识：<h1 ref = "xxx">...</h1> 或者<school ref = "xxx"><school>
   获取：this.$refs.xxx

###    ###配置项props

​      功能：让组件接收外部传过来的数据
​        （1）.传递数据：
​          <Demo name="xxx"/>
​          (2).接收数据：
​            第一种方式（只接收）：
​            props:['name']
​          

          第二种方式（限制类型）：
          props:{
            name:Spring 
          }
    
          第三种方式（限制类型、限制必要性、指定默认值）：
          props:{
            name:{
              type:Spring,  //类型
              required:true,  //必要性
              default:'老王'  //默认值
            }
          }
      备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，
            若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据

### ###mixin（混入）

  功能：可以把多个组件共用的配置提取成一个混入对象
  使用方式：
      第一步定义混合，例如：
          {
            data(){....}
            methods:{....}
            .....
          }
      第二步使用混入，例如：
          （1）.全局混入：Vue.mixin(xxx)
          （2）.局部混入：mixins:['xxx']

### ###插件

  功能：用于增强Vue
  本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据
  定义插件：
  对象.install = function (Vue,options){
    //1.添加全局过滤器
    Vue.filter(...)

    //2.添加全局指令
    Vue.directive(...)
    
    //3.配置全局混入（混合）
    Vue.mixin (.....)


    //4.添加实例方法
    Vue.prototype.$myMethod =function(){...}
    Vue.prototype.$myProperty =xxxx
  }
使用插件：Vue.use()

### ToDolist案例总结

1.组件化编码流程

（1）.拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突

（2）.实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：

​			1）.一个组件在用：放在组件自身即可

​			2）.一些组件在用：放在他们共同的父组件上（状态提升）

（3）.实现交互：从绑定的事件开始

2.props适用于：

（1）父组件==>子组件 通讯

（2）子组件==>父组件  通讯（要求父组件先给子组件一个函数）

3.使用V-model时要切记：V-model绑定的值不能是props传过来的值，因为props是不可以修改的！

4.props传过来的是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做

### 组件的自定义事件

1.一种组件间通信的方式，适用于：子组件 ===> 父组件

2.使用场景：A是父组件，B是子组件，B想给A传数据，name就要在A中给B绑定自定义事件（事件的回调在A）

3.绑定自定义事件：

​	1.第一种方式，在父组件中：<Demo @atguigu ="test"/> 或

```js
<Demo  V-on:atguigu= "test"/>
```

2.第二种方式，在父组件中：

```js
<Demo ref ="demo"/>

......

mounted(){

this.$refs.xxx.$on('atguigu',this.test)

}
```

3.若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。

4.触发自定义事件：this.$emit('atguigu',数据)

5.解绑自定义事件this.$off('atguigu')

6.足尖上也可以绑定原生DOM事件，需要使用native 修饰符

7.注意：通过this.$refs.xxx.$on('atguigu',回调)绑定自定义事件时，回调要么配置在methods中，要么使用箭头函数，否则this指向会出问题！

### 消息订阅与发布

1.一种组件间通信的方式，适用于任意组件间通信

2.使用步骤：

​		1.安装pubsub：npm i pubsub-js

​		2.引入：import pubsub from ’pubsub-js‘

​		3.接收数据： A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身

```
methods(){
demo(data){.....}
}
.....
mouted(){
this.pid = pubsub.subscribe('xxx',this.demo)//订阅消息
}
```

​		4.提供数据：pubsub.publish('xxx',数据)

​		5.最好的beforeDestroy钩子中，用PubSub.unsubscribe(pid)去取消订阅

### nextTick

​	1.语法：this.$nextTick(回调函数)

​	2.作用：在下一次DOM更行结束后执行其指定的回调

​	3.什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行

### 插槽

1作用：让父组件可以向子组件指定位置插入HTML结构，也是一种组件间通讯的方式，适用于父组件===》子组件

2.分类：默认插槽、具名插槽、作用域插槽

3.使用方式：

​	1.默认插槽：

```
父组件中：
		<Category>
			<div>html结构1</div>
		</Category>
子组件中：
		<template>
			<div>
			//定义插槽
			<slot>插槽默认内容</solt>
			</div>
		</template>
```

2.具名插槽

```
父组件中：
	<Category>
		<template slot = "center">
		<div> html结构1</div>
		</template>
		<tempalte v-slot:footer>
		<div> HTML结构2</div>
		</template>
		</Category>
		
```

3.作用域插槽：

​	1.理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（games数据在Category组价中，但是使用数据遍历出来的结构有APP组件决定）

​	2.具体编码：

```
父组件中：
<Category>
<template scope="scopeDate">
//生成的是ul列表
<ul>
	<li v-for = "g in scopeDate.games" :key="g">{{g}}</h4>
	</template>
	</Category>
	子组件中：
	<template>
	<div>
	<slot :games="games"></slot>
	</div>
	</template>
	
	<script>
	export default{
	name:"Category",
	props:['title'],
	
	}
```



### Vuex

##### 1.概念

​	在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue在应用中多个组件的共享状态进行集中式的管理（读写），也是一种组件间通讯的方式，且适用于任意组件间通讯

2.如何使用

​	多个组件需要共享数据时

3.搭建vuex环境

1.创建文件：src/store/index.js

```js
//该文件用于创建Vuex中最为核心的Store
//引入vue
import Vue from 'vue'
// 引入的Vuex
import Vuex from 'vuex'
//应用Vuex插件
Vue.use(Vuex)
//准备actions——用于响应组件中的动作
const action ={}

// 准备mutations——用于操作数据（state）
const mutatuins ={}

//准备state——用于存储数据
const state ={}

// 创建并暴露store
export default new Vuex.Store({
    action:action,
    mutatuins:mutatuins,
    state:state
})
```

##### 2.在main.js中创建vm时传入store配置项

```js
//引入Vue
import Vue from 'vue'
//引入App
import App from './App.vue'
//引入插件
// import vueResource from 'vue-vueResource'
// 引入store
import store from './store'
//关闭Vue的生产提示
Vue.config.productionTip = false
//  Vue.use(vueResource)

//创建vm
const vm = new Vue({
	el:'#App',
	render: h => h(App),
	store,
	beforeCreate(){
		Vue.prototype.$bus= this//安装全局事件总线
	}
})
```

##### 4.基本使用

1. 初始化数据、配置actions、配置mutations、操作文件store.js

   ```js
   //该文件用于创建Vuex中最为核心的Store
   //引入vuex
   import Vue from 'vue'
   // 引入的Vuex
   import Vuex from 'vuex'
   Vue.use(Vuex)
   //准备actions——用于响应组件中的动作
   const actions = {
       jiaAdd(context,value) {
           // console.log('action中的jian被调用了',context,value)
           if(this.state.sum%2){
               context.commit('JIAADD',value)
           }
       },
      
   }
   
   // 准备mutations——用于操作数据（state）
   const mutations = {
       JIA(state,value){
           // console.log('mutations中的JIA被调用',a,b)
           state.sum+=value;
           // console.log(state.sum)
       }
   }
   
   //准备state——用于存储数据
   const state = {
       sum: 0,
   }
   
   // 创建并暴露store
   export default new Vuex.Store({
        actions,
       mutations,
        state
   })
   ```

   ##### 5.getters的使用

   1. 概念：当state中的数据需要经过加工后在使用时，可以使用getters加工

   2. 在store，js中追加getters配置

      ```js
      .....
      const getters = {
      	bigSum(state){
      	return state.sum*10
      	}
      }
      //创建并暴露store
      export default new Vue.Store({
      	.....
      	getters
      })
      ```

      3.组件中读取数据：$store.getters.bigSum(方法返回的数据)

##### 6.四个map方法的使用

1.mapState方法：用于帮助我们映射state中的数据为计算属性

```js
  // 借助mapstate生成计算属性，从state中读取数据。（对象写法）
...mapState({he:'sum',xuexiao:'school',xueke:'subject'})
    // 借助mapState生成计算属性，从state总读取数据。（数据写法）
     ...mapState(['sum','school','subject']),
```

2.mapGetters方法：用于帮助我们映射Getters中数据为计算属性

```js
    ...mapGetters({bigSum:'bigSum'})
    ...mapGetters(['bigSum'])
```

##### 7.模块化命名空间

1.目的：让代码更好维护，让多种数据分类更加明确

2.修改Store.js

3.开启命名空间后，组建中读取state数据：

```js
//方式一：自己直接读取
this.$store.state.personAbout.list
//方式二：借助mapState读取：
...mapState('countAbout',['sum','schoole','subject'])
```

4.开启命名空间后，组件中读取getters数据：

```js
//方式一：自己直接读取
this.$store.getters['personAbout/firstPersonName']
//方式二：借助mapActions读取
...mapGetters('coutAbout',[bigSum])
```

5.开启命名空间后，组件中调用dispatch

```js
方式一：直接dispatch
this.$store.dispatch('personAbout/addPersonWang',personObj)
方式二：借助mapAction
...mapSction('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'})
```

6.开启命名空间后，组件中调用commit

```js
方式一：自己直接调用commit
this.$store.commit('personAbout/ADD_PERSON',person)
//方式二：借助mapMatations:
...mapMatations(countAbout),{increment:'JIA'}
```

### 路由

1.理解：一个路由（route）就是一组映射关系（key-value），多个路由需要路由器（router）去管理

2.前端路由：key是路径，value是组件

##### 1.基本使用

1.安装vue-router：命令：npm i vue-router

2.应用插件：Vue.use（VueRouter）

3.编写router配置项：

```js
// 该文件专门用来创建整个应用的路由器
import VueRouter from "vue-router";
//引入组件
import About from '../components/About.vue';
import Home from '../components/Home.vue'
//创建一个路由器
export default new VueRouter({
    routes:[
        {
            path:'/about',
            component:About
        },
        {
            path:'/home',
            componemt:Home
        }
    ]
})
```

4.实现切换（active-class可配置高亮样式）

```js
	   <router-link class="list-group-item " active-class="active" to="/about">About</router-link>
          <router-link class="list-group-item" active-class="active" to="/home">Home</router-link>
```

5.指定位置展示

```js
<router-view></router-view>
```

##### 2.几个注意点

1.路由组件通常存放在pages文件夹中，一般组件通常存放在component文件夹中

2.通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载

3.每个组件都有自己的$store属性，里面存储着自己的路由信息

4.整个应用只有一个router，可以通过组件的$router属性获取到

##### 3.多级路由

1.配置路由规则，使用children配置项：

```js
routes: [{
			path: '/about',
			component: About
		},
		{
			path: '/home',
			component: Home,
            //通过children设置子级路由
			children: [{
				// 不要加斜杠直接news
				path: 'news',
				component: News,

			},
			{
                // 不要加斜杠直接massage
				path: 'massage',
				component: Massage,

			}]
		}
	]
```

3.路由的query参数

1.传递参数

```js
 <!-- //跳转路由并携带query参数，to的字符串写法 -->
        <!-- <router-link :to="`/home/message/detail?id=${m.id}&title=${m.title}`">{{ m.title }}</router-link -->

 <!-- //跳转路由并携带query参数，to的对象写法 -->
        <router-link
          :to="{
            path: '/home/message/detail',
            query: {
              id: m.id,
              title: m.title,
            },
          }"
          >{{ m.title }}</router-link
        >
```

2.接收参数

$route.query.id

$route.query.title

##### 5.命名路由

1.作用：可以简化路由的跳转

2.如何使用

1.给路由命名

```js
routes: [{
		//给路由命名
			name: 'guanyu',
			path: '/about',
			component: About
		},
		{
			path: '/home',
			component: Home,
			children: [{
					// 不要加斜杠
					path: 'news',
					component: News,

				},
				{
					path: 'message',
					component: Message,
					children: [{
						//给路由命名
						name: 'xiangqing',
						path: 'detail',
						component: Detail,
					}]

				}
			]
```

2.简化跳转

```js
//简化前，需要写完整的路径
<router-link
          to="/home/message/detail"
          >{{ m.title }}</router-link
        >



<router-link
          :to="{
            name: 'xiangqing',
            query: {
              id: m.id,
              title: m.title,
            },
          }"
          >{{ m.title }}</router-link
        >
```

##### 6.路由的params参数

1.配置路由，声明结合搜params参数

```js
	routes: [{
		//给路由命名
			name: 'guanyu',
			path: '/about',
			component: About
		},
		{
			path: '/home',
			component: Home,
			children: [{
					// 不要加斜杠
					path: 'news',
					component: News,

				},
				{
					path: 'message',
					component: Message,
					children: [{
						//给路由命名
						name: 'xiangqing',
						path: 'detail/:id/:title',//使用占位符声明接收的params参数
						component: Detail,
					}]

				}
			]
		}
	]
```

2.传递参数

```js
 <!-- //跳转路由并携带query参数，to的字符串写法 -->
        <!-- <router-link :to="`/home/message/detail/${m.id}&/${m.title}`">{{ m.title }}</router-link> -->

         <!-- 跳转路由并携带params参数，to对象写法 -->
         
         <router-link
          :to="{
            //不可以写path路径方法
            name: 'xiangqing',
            //和query相比改一下为params
            params: {
              id: m.id,
              title: m.title,
            },
          }"
          >{{ m.title }}</router-link
        > 
```

特别注意：路由携带的params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！

3.接收参数

```js
$route.params.title
```

##### 7.路由的props配置

作用：让路由组件更加方便的收到参数

```js
{
						//给路由命名
						name: 'xiangqing',
						path: 'detail/:id/:title', //使用占位符声明接收的params参数
						component: Detail,
						// props的第一种写法，值为对象，该对象中的所有key-value都会以props的形式传给Detail组件
						// props:{
						// 	a:1,
						// 	b:'hello'
						// }

						// props的第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给Detail组件
						// props:true,

						// props的第三种写法，值为函数
						props($route){
							return{
								id:$route.params.id,
								title:$route.params.title
							}
						}
					}]
```

##### 8.<router-link.>的replace属性

1.作用：控制路由跳转时操作浏览器历史记录的模式

2.浏览器的历史记录有两种写入方式：分别为push和replace，push是追加历史纪录，replace是替换当前记录，路由在跳转的时候默认为push

3.如何开启replace模式：<router-link replace ..... >News<./router-link>

##### 9.编程式路由导航

1.作用：不借助<router-link.>实现路由跳转，让路由跳转更加灵活

2.具体编码

```js
//$router的两个API
 this.$router.push({
        name:'xiangqing',
        query:{
          id:m.id,
          title:m.title,
        }
      })

this.$router.replace({
        name:'xiangqing',
        query:{
          id:m.id,
          title:m.title,
        }
      })
this.$router.forward()//前金
this.$router.back()//后退
this.$router.go()//可前进也可后退在括号里写数字
```

##### 10.缓存路由组件

1.作用：让不展示的路由组件保持挂载，不被销毁

2.具体编码：

```js
   //include指的是组件名，路由名字不行     
<keep-alive include="News">
      //缓存多个写成数组
    <keep-alive :include="['News','message']">
      <router-view></router-view>
      </keep-alive>
```

##### 11.两个新的生命周期钩子

1.作用：路由组件 所独有的两个钩子，用于捕获路由组件的激活状态

2.具体名字：

​	1.activated路由组件被激活时触发

​	2.deactivated路由组件失活时触发

##### 12.路由守卫

1.作用：对路由进行权限控制

2.分类：全局守卫、独享守卫、组件内守卫

3.全局守卫：

```js
//全局前置路由守卫，初始化的时候被调用，每一次路由切换之前都会调用beforeEach里函数
router.beforeEach((to, from, next) => {
		// console.log('@')
		
		if (to.meta.isAuth) { //判断是否需要权限
			if (localStorage.getItem('school') === 'HDu') {
				next()
			} else {
				alert('学校名不对，无权限查看')
			}
		} else {
			next()
		}
	},
                  //后置路由守卫，前置路由完成之后执行
	router.afterEach((to, from) => {
		document.title= to.meta.title||'您好!';
		console.log('后置路由守卫', to, from)
	})
)
```

```js
//配置路由元信息
meta: {
						title: '消息',
						isAuth: true
					},
```

4.独享守卫：

```js
beforeEnter(to,from,next){
console.log('beforeEnter',to,from)
if(to.meta.isAuth){
if(localStoreage.getTiem('school')==='atguigu'){
next()
}else{
alert('暂无查看权限')
}
esle{
next()
}
}
}
```

5.组件内路由守卫

```js
//进入守卫：通过路由规则，进入该组件时被调用
beforeRouterEnterto.from,next{
},
//离开守卫：通过路由则会，离开该组件时别调用
beforeRouterLeave(to,form,next){
}
```

##### 13.路由器的两种工作模式

1.对于一个url来说，什么是hash值？ --#及其后面的内容就是hash值

2.hash值不会包含在HTTP请求中，即：hash值不会带给服务器

3.hash模式：

​	1.地址中永远带着#号，不美观

​	2.若以后将地址通过第三方手机APP分享，若APP校验严格，则地址会被标记为不合法

​	3.兼容性较好

4.history模式：

​	1.地址干净，美观

​	2.兼容性和hash模式相比略差

​	3.用用部署上线时需要后端人员支持，解决刷新该页面服务器404的问题